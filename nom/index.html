<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="nom, eating data byte by byte"><title>nom - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="nom" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.0 (8ede3aae2 2023-07-12)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../nom/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../nom/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate nom</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 4.2.3</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">nom</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/nom/lib.rs.html#1-471">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="nom-eating-data-byte-by-byte"><a href="#nom-eating-data-byte-by-byte">nom, eating data byte by byte</a></h2>
<p>nom is a parser combinator library with a focus on safe parsing,
streaming patterns, and as much as possible zero copy.</p>
<h3 id="example"><a href="#example">Example</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>nom;

<span class="attr">#[derive(Debug,PartialEq)]
</span><span class="kw">pub struct </span>Color {
  <span class="kw">pub </span>red:     u8,
  <span class="kw">pub </span>green:   u8,
  <span class="kw">pub </span>blue:    u8,
}

<span class="kw">fn </span>from_hex(input: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;u8, std::num::ParseIntError&gt; {
  u8::from_str_radix(input, <span class="number">16</span>)
}

<span class="kw">fn </span>is_hex_digit(c: char) -&gt; bool {
  c.is_digit(<span class="number">16</span>)
}

<span class="macro">named!</span>(hex_primary&lt;<span class="kw-2">&amp;</span>str, u8&gt;,
  <span class="macro">map_res!</span>(<span class="macro">take_while_m_n!</span>(<span class="number">2</span>, <span class="number">2</span>, is_hex_digit), from_hex)
);

<span class="macro">named!</span>(hex_color&lt;<span class="kw-2">&amp;</span>str, Color&gt;,
  <span class="macro">do_parse!</span>(
           <span class="macro">tag!</span>(<span class="string">&quot;#&quot;</span>)   &gt;&gt;
    red:   hex_primary &gt;&gt;
    green: hex_primary &gt;&gt;
    blue:  hex_primary &gt;&gt;
    (Color { red, green, blue })
  )
);

<span class="kw">fn </span>main() {
  <span class="macro">assert_eq!</span>(hex_color(<span class="string">&quot;#2F14DF&quot;</span>), <span class="prelude-val">Ok</span>((<span class="string">&quot;&quot;</span>, Color {
    red: <span class="number">47</span>,
    green: <span class="number">20</span>,
    blue: <span class="number">223</span>,
  })));
}</code></pre></div>
<p>The code is available on <a href="https://github.com/Geal/nom">Github</a></p>
<p>There are a few <a href="https://github.com/Geal/nom/tree/master/doc">guides</a> with more details
about <a href="https://github.com/Geal/nom/blob/master/doc/how_nom_macros_work.md">the design of nom</a>,
<a href="https://github.com/Geal/nom/blob/master/doc/making_a_new_parser_from_scratch.md">how to write parsers</a>,
or the <a href="https://github.com/Geal/nom/blob/master/doc/error_management.md">error management system</a>.</p>
<p><strong>Looking for a specific combinator? Read the
<a href="https://github.com/Geal/nom/blob/master/doc/choosing_a_combinator.md">“choose a combinator” guide</a></strong></p>
<p>If you are upgrading to nom 2.0, please read the
<a href="https://github.com/Geal/nom/blob/master/doc/upgrading_to_nom_2.md">migration document</a>.</p>
<p>If you are upgrading to nom 4.0, please read the
<a href="https://github.com/Geal/nom/blob/master/doc/upgrading_to_nom_4.md">migration document</a>.</p>
<p>See also the <a href="https://github.com/Geal/nom/blob/master/doc/FAQ.md">FAQ</a>.</p>
<h3 id="parser-combinators"><a href="#parser-combinators">Parser combinators</a></h3>
<p>Parser combinators are an approach to parsers that is very different from
software like <a href="https://en.wikipedia.org/wiki/Lex_(software)">lex</a> and
<a href="https://en.wikipedia.org/wiki/Yacc">yacc</a>. Instead of writing the grammar
in a separate file and generating the corresponding code, you use very small
functions with very specific purpose, like “take 5 bytes”, or “recognize the
word ‘HTTP’”, and assemble then in meaningful patterns like “recognize
‘HTTP’, then a space, then a version”.
The resulting code is small, and looks like the grammar you would have
written with other parser approaches.</p>
<p>This has a few advantages:</p>
<ul>
<li>the parsers are small and easy to write</li>
<li>the parsers components are easy to reuse (if they’re general enough, please add them to nom!)</li>
<li>the parsers components are easy to test separately (unit tests and property-based tests)</li>
<li>the parser combination code looks close to the grammar you would have written</li>
<li>you can build partial parsers, specific to the data you need at the moment, and ignore the rest</li>
</ul>
<p>Here is an example of one such parser, to recognize text between parentheses:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>nom;

<span class="macro">named!</span>(parens, <span class="macro">delimited!</span>(<span class="macro">char!</span>(<span class="string">&#39;(&#39;</span>), <span class="macro">is_not!</span>(<span class="string">&quot;)&quot;</span>), <span class="macro">char!</span>(<span class="string">&#39;)&#39;</span>)));</code></pre></div>
<p>It defines a function named <code>parens</code>, which will recognize a sequence of the character <code>(</code>, the longest byte array not containing <code>)</code>, then the character <code>)</code>, and will return the byte array in the middle.</p>
<p>Here is another parser, written without using nom’s macros this time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>nom;

<span class="kw">use </span>nom::{IResult,<span class="prelude-val">Err</span>,Needed};

<span class="kw">fn </span>take4(i:<span class="kw-2">&amp;</span>[u8]) -&gt; IResult&lt;<span class="kw-2">&amp;</span>[u8], <span class="kw-2">&amp;</span>[u8]&gt;{
  <span class="kw">if </span>i.len() &lt; <span class="number">4 </span>{
    <span class="prelude-val">Err</span>(Err::Incomplete(Needed::Size(<span class="number">4</span>)))
  } <span class="kw">else </span>{
    <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span>i[<span class="number">4</span>..],<span class="kw-2">&amp;</span>i[<span class="number">0</span>..<span class="number">4</span>]))
  }
}</code></pre></div>
<p>This function takes a byte array as input, and tries to consume 4 bytes.
Writing all the parsers manually, like this, is dangerous, despite Rust’s safety features. There
are still a lot of mistakes one can make. That’s why nom provides a list of macros to help in
developing parsers.</p>
<p>With macros, you would write it like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>nom;

<span class="macro">named!</span>(take4, <span class="macro">take!</span>(<span class="number">4</span>));</code></pre></div>
<p>A parser in nom is a function which, for an input type <code>I</code>, an output type <code>O</code>
and an optional error type <code>E</code>, will have the following signature:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>parser(input: I) -&gt; IResult&lt;I, O, E&gt;;</code></pre></div>
<p>Or like this, if you don’t want to specify a custom error type (it will be <code>u32</code> by default):</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>parser(input: I) -&gt; IResult&lt;I, O&gt;;</code></pre></div>
<p><code>IResult</code> is an alias for the <code>Result</code> type:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>nom::{Needed, Context};

<span class="kw">type </span>IResult&lt;I, O, E = u32&gt; = <span class="prelude-ty">Result</span>&lt;(I, O), <span class="prelude-val">Err</span>&lt;I, E&gt;&gt;;

<span class="kw">enum </span><span class="prelude-val">Err</span>&lt;I, E = u32&gt; {
  Incomplete(Needed),
  Error(Context&lt;I, E&gt;),
  Failure(Context&lt;I, E&gt;),
}</code></pre></div>
<p>It can have the following values:</p>
<ul>
<li>a correct result <code>Ok((I,O))</code> with the first element being the remaining of the input (not parsed yet), and the second the output value;</li>
<li>an error <code>Err(Err::Error(c))</code> with <code>c</code> an enum that contains an error code with its position in the input, and optionally a chain of accumulated errors;</li>
<li>an error <code>Err(Err::Incomplete(Needed))</code> indicating that more input is necessary. <code>Needed</code> can indicate how much data is needed</li>
<li>an error <code>Err(Err::Failure(c))</code>. It works like the <code>Error</code> case, except it indicates an unrecoverable error: we cannot backtrack and test another parser</li>
</ul>
<p>Please refer to the [documentation][doc] for an exhaustive list of parsers. See also the
<a href="https://github.com/Geal/nom/blob/master/doc/choosing_a_combinator.md">“choose a combinator” guide</a>**.</p>
<h3 id="making-new-parsers-with-macros"><a href="#making-new-parsers-with-macros">Making new parsers with macros</a></h3>
<p>Macros are the main way to make new parsers by combining other ones. Those macros accept other macros or function names as arguments. You then need to make a function out of that combinator with <strong><code>named!</code></strong>, or a closure with <strong><code>closure!</code></strong>. Here is how you would do, with the <strong><code>tag!</code></strong> and <strong><code>take!</code></strong> combinators:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">named!</span>(abcd_parser, <span class="macro">tag!</span>(<span class="string">&quot;abcd&quot;</span>)); <span class="comment">// will consume bytes if the input begins with &quot;abcd&quot;

</span><span class="macro">named!</span>(take_10, <span class="macro">take!</span>(<span class="number">10</span>));        <span class="comment">// will consume and return 10 bytes of input</span></code></pre></div>
<p>The <strong><code>named!</code></strong> macro can take three different syntaxes:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="macro">named!</span>(my_function( <span class="kw-2">&amp;</span>[u8] ) -&gt; <span class="kw-2">&amp;</span>[u8], <span class="macro">tag!</span>(<span class="string">&quot;abcd&quot;</span>));

<span class="macro">named!</span>(my_function&lt;<span class="kw-2">&amp;</span>[u8], <span class="kw-2">&amp;</span>[u8]&gt;, <span class="macro">tag!</span>(<span class="string">&quot;abcd&quot;</span>));

<span class="macro">named!</span>(my_function, <span class="macro">tag!</span>(<span class="string">&quot;abcd&quot;</span>)); <span class="comment">// when you know the parser takes &amp;[u8] as input, and returns &amp;[u8] as output</span></code></pre></div>
<p><strong>IMPORTANT NOTE</strong>: Rust’s macros can be very sensitive to the syntax, so you may encounter an error compiling parsers like this one:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">named!</span>(my_function&lt;<span class="kw-2">&amp;</span>[u8], Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt;&gt;, <span class="macro">many0!</span>(<span class="macro">tag!</span>(<span class="string">&quot;abcd&quot;</span>)));
</code></pre></div>
<p>You will get the following error: <code>error: expected an item keyword</code>. This
happens because <code>&gt;&gt;</code> is seen as an operator, so the macro parser does not
recognize what we want. There is a way to avoid it, by inserting a space:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">named!</span>(my_function&lt;<span class="kw-2">&amp;</span>[u8], Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; &gt;, <span class="macro">many0!</span>(<span class="macro">tag!</span>(<span class="string">&quot;abcd&quot;</span>)));</code></pre></div>
<p>This will compile correctly. I am very sorry for this inconvenience.</p>
<h3 id="combining-parsers"><a href="#combining-parsers">Combining parsers</a></h3>
<p>There are more high level patterns, like the <strong><code>alt!</code></strong> combinator, which provides a choice between multiple parsers. If one branch fails, it tries the next, and returns the result of the first parser that succeeds:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">named!</span>(alt_tags, <span class="macro">alt!</span>(<span class="macro">tag!</span>(<span class="string">&quot;abcd&quot;</span>) | <span class="macro">tag!</span>(<span class="string">&quot;efgh&quot;</span>)));

<span class="macro">assert_eq!</span>(alt_tags(<span class="string">b&quot;abcdxxx&quot;</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;xxx&quot;</span>[..], <span class="kw-2">&amp;</span><span class="string">b&quot;abcd&quot;</span>[..])));
<span class="macro">assert_eq!</span>(alt_tags(<span class="string">b&quot;efghxxx&quot;</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;xxx&quot;</span>[..], <span class="kw-2">&amp;</span><span class="string">b&quot;efgh&quot;</span>[..])));
<span class="macro">assert_eq!</span>(alt_tags(<span class="string">b&quot;ijklxxx&quot;</span>), <span class="prelude-val">Err</span>(nom::Err::Error(<span class="macro">error_position!</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;ijklxxx&quot;</span>[..], nom::ErrorKind::Alt))));</code></pre></div>
<p>The pipe <code>|</code> character is used as separator.</p>
<p>The <strong><code>opt!</code></strong> combinator makes a parser optional. If the child parser returns an error, <strong><code>opt!</code></strong> will succeed and return None:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">named!</span>( abcd_opt&lt; <span class="kw-2">&amp;</span>[u8], <span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;</span>[u8]&gt; &gt;, <span class="macro">opt!</span>( <span class="macro">tag!</span>(<span class="string">&quot;abcd&quot;</span>) ) );

<span class="macro">assert_eq!</span>(abcd_opt(<span class="string">b&quot;abcdxxx&quot;</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;xxx&quot;</span>[..], <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;abcd&quot;</span>[..]))));
<span class="macro">assert_eq!</span>(abcd_opt(<span class="string">b&quot;efghxxx&quot;</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;efghxxx&quot;</span>[..], <span class="prelude-val">None</span>)));</code></pre></div>
<p><strong><code>many0!</code></strong> applies a parser 0 or more times, and returns a vector of the aggregated results:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::str;

<span class="macro">named!</span>(multi&lt; Vec&lt;<span class="kw-2">&amp;</span>str&gt; &gt;, <span class="macro">many0!</span>( <span class="macro">map_res!</span>(<span class="macro">tag!</span>( <span class="string">&quot;abcd&quot; </span>), str::from_utf8) ) );
<span class="kw">let </span>a = <span class="string">b&quot;abcdef&quot;</span>;
<span class="kw">let </span>b = <span class="string">b&quot;abcdabcdef&quot;</span>;
<span class="kw">let </span>c = <span class="string">b&quot;azerty&quot;</span>;
<span class="macro">assert_eq!</span>(multi(a), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;ef&quot;</span>[..],     <span class="macro">vec!</span>[<span class="string">&quot;abcd&quot;</span>])));
<span class="macro">assert_eq!</span>(multi(b), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;ef&quot;</span>[..],     <span class="macro">vec!</span>[<span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;abcd&quot;</span>])));
<span class="macro">assert_eq!</span>(multi(c), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;azerty&quot;</span>[..], Vec::new())));</code></pre></div>
<p>Here are some basic combining macros available:</p>
<ul>
<li><strong><code>opt!</code></strong>: will make the parser optional (if it returns the <code>O</code> type, the new parser returns <code>Option&lt;O&gt;</code>)</li>
<li><strong><code>many0!</code></strong>: will apply the parser 0 or more times (if it returns the <code>O</code> type, the new parser returns <code>Vec&lt;O&gt;</code>)</li>
<li><strong><code>many1!</code></strong>: will apply the parser 1 or more times</li>
</ul>
<p>There are more complex (and more useful) parsers like <code>do_parse!</code> and <code>tuple!</code>, which are used to apply a series of parsers then assemble their results.</p>
<p>Example with <code>tuple!</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>nom::{ErrorKind, Needed,be_u16};

<span class="macro">named!</span>(tpl&lt;<span class="kw-2">&amp;</span>[u8], (u16, <span class="kw-2">&amp;</span>[u8], <span class="kw-2">&amp;</span>[u8]) &gt;,
  <span class="macro">tuple!</span>(
    be_u16 ,
    <span class="macro">take!</span>(<span class="number">3</span>),
    <span class="macro">tag!</span>(<span class="string">&quot;fg&quot;</span>)
  )
);

<span class="macro">assert_eq!</span>(
  tpl(<span class="kw-2">&amp;</span><span class="string">b&quot;abcdefgh&quot;</span>[..]),
  <span class="prelude-val">Ok</span>((
    <span class="kw-2">&amp;</span><span class="string">b&quot;h&quot;</span>[..],
    (<span class="number">0x6162u16</span>, <span class="kw-2">&amp;</span><span class="string">b&quot;cde&quot;</span>[..], <span class="kw-2">&amp;</span><span class="string">b&quot;fg&quot;</span>[..])
  ))
);
<span class="macro">assert_eq!</span>(tpl(<span class="kw-2">&amp;</span><span class="string">b&quot;abcde&quot;</span>[..]), <span class="prelude-val">Err</span>(nom::Err::Incomplete(Needed::Size(<span class="number">2</span>))));
<span class="kw">let </span>input = <span class="kw-2">&amp;</span><span class="string">b&quot;abcdejk&quot;</span>[..];
<span class="macro">assert_eq!</span>(tpl(input), <span class="prelude-val">Err</span>(nom::Err::Error(<span class="macro">error_position!</span>(<span class="kw-2">&amp;</span>input[<span class="number">5</span>..], ErrorKind::Tag))));</code></pre></div>
<p>Example with <code>do_parse!</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>nom::IResult;

<span class="attr">#[derive(Debug, PartialEq)]
</span><span class="kw">struct </span>A {
  a: u8,
  b: u8
}

<span class="kw">fn </span>ret_int1(i:<span class="kw-2">&amp;</span>[u8]) -&gt; IResult&lt;<span class="kw-2">&amp;</span>[u8], u8&gt; { <span class="prelude-val">Ok</span>((i,<span class="number">1</span>)) }
<span class="kw">fn </span>ret_int2(i:<span class="kw-2">&amp;</span>[u8]) -&gt; IResult&lt;<span class="kw-2">&amp;</span>[u8], u8&gt; { <span class="prelude-val">Ok</span>((i,<span class="number">2</span>)) }

<span class="macro">named!</span>(f&lt;<span class="kw-2">&amp;</span>[u8],A&gt;,
  <span class="macro">do_parse!</span>(    <span class="comment">// the parser takes a byte array as input, and returns an A struct
    </span><span class="macro">tag!</span>(<span class="string">&quot;abcd&quot;</span>)       &gt;&gt;      <span class="comment">// begins with &quot;abcd&quot;
    </span><span class="macro">opt!</span>(<span class="macro">tag!</span>(<span class="string">&quot;abcd&quot;</span>)) &gt;&gt;      <span class="comment">// this is an optional parser
    </span>aa: ret_int1       &gt;&gt;      <span class="comment">// the return value of ret_int1, if it does not fail, will be stored in aa
    </span><span class="macro">tag!</span>(<span class="string">&quot;efgh&quot;</span>)       &gt;&gt;
    bb: ret_int2       &gt;&gt;
    <span class="macro">tag!</span>(<span class="string">&quot;efgh&quot;</span>)       &gt;&gt;

    (A{a: aa, b: bb})          <span class="comment">// the final tuple will be able to use the variable defined previously
  </span>)
);

<span class="kw">let </span>r = f(<span class="string">b&quot;abcdabcdefghefghX&quot;</span>);
<span class="macro">assert_eq!</span>(r, <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;X&quot;</span>[..], A{a: <span class="number">1</span>, b: <span class="number">2</span>})));

<span class="kw">let </span>r2 = f(<span class="string">b&quot;abcdefghefghX&quot;</span>);
<span class="macro">assert_eq!</span>(r2, <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;X&quot;</span>[..], A{a: <span class="number">1</span>, b: <span class="number">2</span>})));</code></pre></div>
<p>The double right arrow <code>&gt;&gt;</code> is used as separator between every parser in the sequence, and the last closure can see the variables storing the result of parsers. Unless the specified return type is already a tuple, the final line should be that type wrapped in a tuple.</p>
<p>More examples of <a href="macro.do_parse.html"><code>do_parse!</code></a> and <a href="macro.tuple.html"><code>tuple!</code></a> usage can be found in the <a href="tests/ini.rs">INI file parser example</a>.</p>
<p><strong>Going further:</strong> read the <a href="https://github.com/Geal/nom/tree/master/doc">guides</a>!</p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name"><code>pub use self::<a class="mod" href="simple_errors/index.html" title="mod nom::simple_errors">simple_errors</a>::*;</code></div></li><li><div class="item-name"><code>pub use self::<a class="mod" href="methods/index.html" title="mod nom::methods">methods</a>::*;</code></div></li><li><div class="item-name"><code>pub use self::<a class="mod" href="bits/index.html" title="mod nom::bits">bits</a>::*;</code></div></li><li><div class="item-name"><code>pub use self::<a class="mod" href="whitespace/index.html" title="mod nom::whitespace">whitespace</a>::*;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="bits/index.html" title="mod nom::bits">bits</a></div><div class="desc docblock-short">Bit level parsers and combinators</div></li><li><div class="item-name"><a class="mod" href="lib/index.html" title="mod nom::lib">lib</a></div><div class="desc docblock-short">Lib module to re-export everything needed from <code>std</code> or <code>core</code>/<code>alloc</code>. This is how <code>serde</code> does
it, albeit there it is not public.</div></li><li><div class="item-name"><a class="mod" href="methods/index.html" title="mod nom::methods">methods</a></div><div class="desc docblock-short">Method macro combinators</div></li><li><div class="item-name"><a class="mod" href="simple_errors/index.html" title="mod nom::simple_errors">simple_errors</a></div><div class="desc docblock-short">Error management</div></li><li><div class="item-name"><a class="mod" href="types/index.html" title="mod nom::types">types</a></div><div class="desc docblock-short">Custom input types</div></li><li><div class="item-name"><a class="mod" href="whitespace/index.html" title="mod nom::whitespace">whitespace</a></div><div class="desc docblock-short">Support for whitespace delimited formats</div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.add_return_error.html" title="macro nom::add_return_error">add_return_error</a></div><div class="desc docblock-short">Add an error if the child parser fails</div></li><li><div class="item-name"><a class="macro" href="macro.alt.html" title="macro nom::alt">alt</a></div><div class="desc docblock-short">Try a list of parsers and return the result of the first successful one</div></li><li><div class="item-name"><a class="macro" href="macro.alt_complete.html" title="macro nom::alt_complete">alt_complete</a></div><div class="desc docblock-short">Is equivalent to the <code>alt!</code> combinator, except that it will not return <code>Incomplete</code>
when one of the constituting parsers returns <code>Incomplete</code>. Instead, it will try the
next alternative in the chain.</div></li><li><div class="item-name"><a class="macro" href="macro.apply.html" title="macro nom::apply">apply</a></div><div class="desc docblock-short">emulate function currying: <code>apply!(my_function, arg1, arg2, ...)</code> becomes <code>my_function(input, arg1, arg2, ...)</code></div></li><li><div class="item-name"><a class="macro" href="macro.apply_m.html" title="macro nom::apply_m">apply_m</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">emulate function currying for method calls on structs
<code>apply_m!(self.my_function, arg1, arg2, ...)</code> becomes <code>self.my_function(input, arg1, arg2, ...)</code></div></li><li><div class="item-name"><a class="macro" href="macro.bits.html" title="macro nom::bits">bits</a></div><div class="desc docblock-short">Transforms its byte slice input into a bit stream for the underlying parser. This allows the
given bit stream parser to work on a byte slice input.</div></li><li><div class="item-name"><a class="macro" href="macro.bytes.html" title="macro nom::bytes">bytes</a></div><div class="desc docblock-short">Counterpart to bits, bytes! transforms its bit stream input into a byte slice for the underlying
parser, allowing byte-slice parsers to work on bit streams.</div></li><li><div class="item-name"><a class="macro" href="macro.call.html" title="macro nom::call">call</a></div><div class="desc docblock-short">Used to wrap common expressions and function as macros</div></li><li><div class="item-name"><a class="macro" href="macro.call_m.html" title="macro nom::call_m">call_m</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">Used to called methods then move self back into self</div></li><li><div class="item-name"><a class="macro" href="macro.char.html" title="macro nom::char">char</a></div><div class="desc docblock-short">matches one character: `char!(char) =&gt; &amp;<a href="https://doc.rust-lang.org/1.71.0/std/primitive.u8.html" title="primitive u8">u8</a> -&gt; IResult&lt;&amp;<a href="https://doc.rust-lang.org/1.71.0/std/primitive.u8.html" title="primitive u8">u8</a>, char&gt;</div></li><li><div class="item-name"><a class="macro" href="macro.closure.html" title="macro nom::closure">closure</a></div><div class="desc docblock-short">Wraps a parser in a closure</div></li><li><div class="item-name"><a class="macro" href="macro.complete.html" title="macro nom::complete">complete</a></div><div class="desc docblock-short">replaces a <code>Incomplete</code> returned by the child parser
with an <code>Error</code></div></li><li><div class="item-name"><a class="macro" href="macro.cond.html" title="macro nom::cond">cond</a></div><div class="desc docblock-short"><code>cond!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
Conditional combinator</div></li><li><div class="item-name"><a class="macro" href="macro.cond_reduce.html" title="macro nom::cond_reduce">cond_reduce</a></div><div class="desc docblock-short"><code>cond_reduce!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
Conditional combinator with error</div></li><li><div class="item-name"><a class="macro" href="macro.cond_with_error.html" title="macro nom::cond_with_error">cond_with_error</a></div><div class="desc docblock-short"><code>cond_with_error!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
Conditional combinator</div></li><li><div class="item-name"><a class="macro" href="macro.count.html" title="macro nom::count">count</a></div><div class="desc docblock-short"><code>count!(I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the child parser a specified number of times</div></li><li><div class="item-name"><a class="macro" href="macro.count_fixed.html" title="macro nom::count_fixed">count_fixed</a></div><div class="desc docblock-short"><code>count_fixed!(O, I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, [O; nb]&gt;</code>
Applies the child parser a fixed number of times and returns a fixed size array
The type must be specified and it must be <code>Copy</code></div></li><li><div class="item-name"><a class="macro" href="macro.dbg.html" title="macro nom::dbg">dbg</a></div><div class="desc docblock-short">Prints a message if the parser fails</div></li><li><div class="item-name"><a class="macro" href="macro.dbg_dmp.html" title="macro nom::dbg_dmp">dbg_dmp</a></div><div class="desc docblock-short">Prints a message and the input if the parser fails</div></li><li><div class="item-name"><a class="macro" href="macro.delimited.html" title="macro nom::delimited">delimited</a></div><div class="desc docblock-short"><code>delimited!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,U&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
delimited(opening, X, closing) returns X</div></li><li><div class="item-name"><a class="macro" href="macro.do_parse.html" title="macro nom::do_parse">do_parse</a></div><div class="desc docblock-short"><code>do_parse!(I-&gt;IResult&lt;I,A&gt; &gt;&gt; I-&gt;IResult&lt;I,B&gt; &gt;&gt; ... I-&gt;IResult&lt;I,X&gt; , ( O ) ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
do_parse applies sub parsers in a sequence.
it can store intermediary results and make them available
for later parsers</div></li><li><div class="item-name"><a class="macro" href="macro.eat_separator.html" title="macro nom::eat_separator">eat_separator</a></div><div class="desc docblock-short">helper macros to build a separator parser</div></li><li><div class="item-name"><a class="macro" href="macro.eof.html" title="macro nom::eof">eof</a></div><div class="desc docblock-short"><code>eof!()</code> returns its input if it is at the end of input data</div></li><li><div class="item-name"><a class="macro" href="macro.error_node_position.html" title="macro nom::error_node_position">error_node_position</a></div><div class="desc docblock-short">creates a parse error from a <code>nom::ErrorKind</code>,
the position in the input and the next error in
the parsing tree.
if “verbose-errors” is not activated,
it default to only the error code</div></li><li><div class="item-name"><a class="macro" href="macro.error_position.html" title="macro nom::error_position">error_position</a></div><div class="desc docblock-short">creates a parse error from a <code>nom::ErrorKind</code>
and the position in the input
if “verbose-errors” is not activated,
it default to only the error code</div></li><li><div class="item-name"><a class="macro" href="macro.escaped.html" title="macro nom::escaped">escaped</a></div><div class="desc docblock-short"><code>escaped!(T -&gt; IResult&lt;T, T&gt;, U, T -&gt; IResult&lt;T, T&gt;) =&gt; T -&gt; IResult&lt;T, T&gt; where T: InputIter, U: AsChar</code>
matches a byte string with escaped characters.</div></li><li><div class="item-name"><a class="macro" href="macro.escaped_transform.html" title="macro nom::escaped_transform">escaped_transform</a></div><div class="desc docblock-short"><code>escaped_transform!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], Vec&lt;T&gt;&gt;</code>
matches a byte string with escaped characters.</div></li><li><div class="item-name"><a class="macro" href="macro.exact.html" title="macro nom::exact">exact</a></div><div class="desc docblock-short"><code>exact!()</code> will fail if the child parser does not consume the whole data</div></li><li><div class="item-name"><a class="macro" href="macro.expr_opt.html" title="macro nom::expr_opt">expr_opt</a></div><div class="desc docblock-short"><code>expr_opt!(Option&lt;O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
evaluate an expression that returns a Option<T> and returns a Ok((I,T)) if Some</div></li><li><div class="item-name"><a class="macro" href="macro.expr_res.html" title="macro nom::expr_res">expr_res</a></div><div class="desc docblock-short"><code>expr_res!(Result&lt;E,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
evaluate an expression that returns a Result&lt;T,E&gt; and returns a Ok((I,T)) if Ok</div></li><li><div class="item-name"><a class="macro" href="macro.fix_error.html" title="macro nom::fix_error">fix_error</a></div><div class="desc docblock-short">translate parser result from IResult&lt;I,O,u32&gt; to IResult&lt;I,O,E&gt; with a custom type</div></li><li><div class="item-name"><a class="macro" href="macro.flat_map.html" title="macro nom::flat_map">flat_map</a></div><div class="desc docblock-short"><code>flat_map!(R -&gt; IResult&lt;R,S&gt;, S -&gt; IResult&lt;S,T&gt;) =&gt; R -&gt; IResult&lt;R, T&gt;</code></div></li><li><div class="item-name"><a class="macro" href="macro.fold_many0.html" title="macro nom::fold_many0">fold_many0</a></div><div class="desc docblock-short"><code>fold_many0!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser 0 or more times and folds the list of return values</div></li><li><div class="item-name"><a class="macro" href="macro.fold_many1.html" title="macro nom::fold_many1">fold_many1</a></div><div class="desc docblock-short"><code>fold_many1!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser 1 or more times and folds the list of return values</div></li><li><div class="item-name"><a class="macro" href="macro.fold_many_m_n.html" title="macro nom::fold_many_m_n">fold_many_m_n</a></div><div class="desc docblock-short"><code>fold_many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser between m and n times (n included) and folds the list of return value</div></li><li><div class="item-name"><a class="macro" href="macro.i16.html" title="macro nom::i16">i16</a></div><div class="desc docblock-short">if the parameter is nom::Endianness::Big, parse a big endian i16 integer,
otherwise a little endian i16 integer</div></li><li><div class="item-name"><a class="macro" href="macro.i32.html" title="macro nom::i32">i32</a></div><div class="desc docblock-short">if the parameter is nom::Endianness::Big, parse a big endian i32 integer,
otherwise a little endian i32 integer</div></li><li><div class="item-name"><a class="macro" href="macro.i64.html" title="macro nom::i64">i64</a></div><div class="desc docblock-short">if the parameter is nom::Endianness::Big, parse a big endian i64 integer,
otherwise a little endian i64 integer</div></li><li><div class="item-name"><a class="macro" href="macro.i128.html" title="macro nom::i128">i128</a></div><div class="desc docblock-short">if the parameter is nom::Endianness::Big, parse a big endian i64 integer,
otherwise a little endian i64 integer</div></li><li><div class="item-name"><a class="macro" href="macro.is_a.html" title="macro nom::is_a">is_a</a></div><div class="desc docblock-short"><code>is_a!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes that appear in the provided array</div></li><li><div class="item-name"><a class="macro" href="macro.is_a_s.html" title="macro nom::is_a_s">is_a_s</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short"><code>is_a_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters that appear in the provided array</div></li><li><div class="item-name"><a class="macro" href="macro.is_not.html" title="macro nom::is_not">is_not</a></div><div class="desc docblock-short"><code>is_not!(&amp;[T:AsBytes]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes that do not appear in the provided array</div></li><li><div class="item-name"><a class="macro" href="macro.is_not_s.html" title="macro nom::is_not_s">is_not_s</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short"><code>is_not_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters that do not appear in the provided array</div></li><li><div class="item-name"><a class="macro" href="macro.length_bytes.html" title="macro nom::length_bytes">length_bytes</a></div><div class="desc docblock-short"><code>length_bytes!(&amp;[T] -&gt; IResult&lt;&amp;[T], nb&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
Gets a number from the first parser, then extracts that many bytes from the
remaining stream</div></li><li><div class="item-name"><a class="macro" href="macro.length_count.html" title="macro nom::length_count">length_count</a></div><div class="desc docblock-short"><code>length_count!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
gets a number from the first parser, then applies the second parser that many times</div></li><li><div class="item-name"><a class="macro" href="macro.length_data.html" title="macro nom::length_data">length_data</a></div><div class="desc docblock-short"><code>length_data!(I -&gt; IResult&lt;I, nb&gt;) =&gt; O</code></div></li><li><div class="item-name"><a class="macro" href="macro.length_value.html" title="macro nom::length_value">length_value</a></div><div class="desc docblock-short"><code>length_value!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code></div></li><li><div class="item-name"><a class="macro" href="macro.many0.html" title="macro nom::many0">many0</a></div><div class="desc docblock-short"><code>many0!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser 0 or more times and returns the list of results in a Vec.</div></li><li><div class="item-name"><a class="macro" href="macro.many0_count.html" title="macro nom::many0_count">many0_count</a></div><div class="desc docblock-short"><code>many0_count!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, usize&gt;</code>
Applies the parser 0 or more times and returns the number of times the parser was applied.</div></li><li><div class="item-name"><a class="macro" href="macro.many1.html" title="macro nom::many1">many1</a></div><div class="desc docblock-short"><code>many1!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser 1 or more times and returns the list of results in a Vec</div></li><li><div class="item-name"><a class="macro" href="macro.many1_count.html" title="macro nom::many1_count">many1_count</a></div><div class="desc docblock-short"><code>many1_count!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, usize&gt;</code>
Applies the parser 1 or more times and returns the number of times the parser was applied.</div></li><li><div class="item-name"><a class="macro" href="macro.many_m_n.html" title="macro nom::many_m_n">many_m_n</a></div><div class="desc docblock-short"><code>many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser between m and n times (n included) and returns the list of
results in a Vec</div></li><li><div class="item-name"><a class="macro" href="macro.many_till.html" title="macro nom::many_till">many_till</a></div><div class="desc docblock-short"><code>many_till!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (Vec&lt;O&gt;, P)&gt;</code>
Applies the first parser until the second applies. Returns a tuple containing the list
of results from the first in a Vec and the result of the second.</div></li><li><div class="item-name"><a class="macro" href="macro.map.html" title="macro nom::map">map</a></div><div class="desc docblock-short"><code>map!(I -&gt; IResult&lt;I,O&gt;, O -&gt; P) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function on the result of a parser</div></li><li><div class="item-name"><a class="macro" href="macro.map_opt.html" title="macro nom::map_opt">map_opt</a></div><div class="desc docblock-short"><code>map_opt!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Option&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning an Option on the output of a parser</div></li><li><div class="item-name"><a class="macro" href="macro.map_res.html" title="macro nom::map_res">map_res</a></div><div class="desc docblock-short"><code>map_res!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Result&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning a Result on the output of a parser</div></li><li><div class="item-name"><a class="macro" href="macro.map_res_err.html" title="macro nom::map_res_err">map_res_err</a></div><div class="desc docblock-short"><code>map_res_err!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Result&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning a Result on the output of a parser, preserving the returned error</div></li><li><div class="item-name"><a class="macro" href="macro.method.html" title="macro nom::method">method</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">Makes a method from a parser combination</div></li><li><div class="item-name"><a class="macro" href="macro.named.html" title="macro nom::named">named</a></div><div class="desc docblock-short">Makes a function from a parser combination</div></li><li><div class="item-name"><a class="macro" href="macro.named_args.html" title="macro nom::named_args">named_args</a></div><div class="desc docblock-short">Makes a function from a parser combination with arguments.</div></li><li><div class="item-name"><a class="macro" href="macro.named_attr.html" title="macro nom::named_attr">named_attr</a></div><div class="desc docblock-short">Makes a function from a parser combination, with attributes</div></li><li><div class="item-name"><a class="macro" href="macro.nom_compile_error.html" title="macro nom::nom_compile_error">nom_compile_error</a></div></li><li><div class="item-name"><a class="macro" href="macro.nom_line.html" title="macro nom::nom_line">nom_line</a></div></li><li><div class="item-name"><a class="macro" href="macro.nom_println.html" title="macro nom::nom_println">nom_println</a></div></li><li><div class="item-name"><a class="macro" href="macro.nom_stringify.html" title="macro nom::nom_stringify">nom_stringify</a></div></li><li><div class="item-name"><a class="macro" href="macro.none_of.html" title="macro nom::none_of">none_of</a></div><div class="desc docblock-short">matches anything but the provided characters</div></li><li><div class="item-name"><a class="macro" href="macro.not.html" title="macro nom::not">not</a></div><div class="desc docblock-short"><code>not!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns a result only if the embedded parser returns Error or Err(Err::Incomplete)
does not consume the input</div></li><li><div class="item-name"><a class="macro" href="macro.one_of.html" title="macro nom::one_of">one_of</a></div><div class="desc docblock-short">matches one of the provided characters</div></li><li><div class="item-name"><a class="macro" href="macro.opt.html" title="macro nom::opt">opt</a></div><div class="desc docblock-short"><code>opt!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
make the underlying parser optional</div></li><li><div class="item-name"><a class="macro" href="macro.opt_res.html" title="macro nom::opt_res">opt_res</a></div><div class="desc docblock-short"><code>opt_res!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Result&lt;nom::Err,O&gt;&gt;</code>
make the underlying parser optional</div></li><li><div class="item-name"><a class="macro" href="macro.pair.html" title="macro nom::pair">pair</a></div><div class="desc docblock-short"><code>pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;</code>
pair(X,Y), returns (x,y)</div></li><li><div class="item-name"><a class="macro" href="macro.parse_to.html" title="macro nom::parse_to">parse_to</a></div><div class="desc docblock-short"><code>parse_to!(O) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
uses the <code>parse</code> method from <code>std::str::FromStr</code> to convert the current
input to the specified type</div></li><li><div class="item-name"><a class="macro" href="macro.peek.html" title="macro nom::peek">peek</a></div><div class="desc docblock-short"><code>peek!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns a result without consuming the input</div></li><li><div class="item-name"><a class="macro" href="macro.permutation.html" title="macro nom::permutation">permutation</a></div><div class="desc docblock-short"><code>permutation!(I -&gt; IResult&lt;I,A&gt;, I -&gt; IResult&lt;I,B&gt;, ... I -&gt; IResult&lt;I,X&gt; ) =&gt; I -&gt; IResult&lt;I, (A,B,...X)&gt;</code>
applies its sub parsers in a sequence, but independent from their order
this parser will only succeed if all of its sub parsers succeed</div></li><li><div class="item-name"><a class="macro" href="macro.preceded.html" title="macro nom::preceded">preceded</a></div><div class="desc docblock-short"><code>preceded!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
preceded(opening, X) returns X</div></li><li><div class="item-name"><a class="macro" href="macro.recognize.html" title="macro nom::recognize">recognize</a></div><div class="desc docblock-short"><code>recognize!(I -&gt; IResult&lt;I, O&gt; ) =&gt; I -&gt; IResult&lt;I, I&gt;</code>
if the child parser was successful, return the consumed input as produced value</div></li><li><div class="item-name"><a class="macro" href="macro.return_error.html" title="macro nom::return_error">return_error</a></div><div class="desc docblock-short">Prevents backtracking if the child parser fails</div></li><li><div class="item-name"><a class="macro" href="macro.sep.html" title="macro nom::sep">sep</a></div><div class="desc docblock-short">sep is the parser rewriting macro for whitespace separated formats</div></li><li><div class="item-name"><a class="macro" href="macro.separated_list.html" title="macro nom::separated_list">separated_list</a></div><div class="desc docblock-short"><code>separated_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
separated_list(sep, X) returns Vec<X> will return Incomplete if there may be more elements</div></li><li><div class="item-name"><a class="macro" href="macro.separated_list_complete.html" title="macro nom::separated_list_complete">separated_list_complete</a></div><div class="desc docblock-short"><code>separated_list_complete!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
This is equivalent to the <code>separated_list!</code> combinator, except that it will return <code>Error</code>
when either the separator or element subparser returns <code>Incomplete</code>.</div></li><li><div class="item-name"><a class="macro" href="macro.separated_nonempty_list.html" title="macro nom::separated_nonempty_list">separated_nonempty_list</a></div><div class="desc docblock-short"><code>separated_nonempty_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
separated_nonempty_list(sep, X) returns Vec<X> will return Incomplete if there may be more elements</div></li><li><div class="item-name"><a class="macro" href="macro.separated_nonempty_list_complete.html" title="macro nom::separated_nonempty_list_complete">separated_nonempty_list_complete</a></div><div class="desc docblock-short"><code>separated_nonempty_list_complete!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
This is equivalent to the <code>separated_nonempty_list!</code> combinator, except that it will return
<code>Error</code> when either the separator or element subparser returns <code>Incomplete</code>.</div></li><li><div class="item-name"><a class="macro" href="macro.separated_pair.html" title="macro nom::separated_pair">separated_pair</a></div><div class="desc docblock-short"><code>separated_pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I, T&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;</code>
separated_pair(X,sep,Y) returns (x,y)</div></li><li><div class="item-name"><a class="macro" href="macro.switch.html" title="macro nom::switch">switch</a></div><div class="desc docblock-short"><code>switch!(I -&gt; IResult&lt;I,P&gt;, P =&gt; I -&gt; IResult&lt;I,O&gt; | ... | P =&gt; I -&gt; IResult&lt;I,O&gt; ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
choose the next parser depending on the result of the first one, if successful,
and returns the result of the second parser</div></li><li><div class="item-name"><a class="macro" href="macro.tag.html" title="macro nom::tag">tag</a></div><div class="desc docblock-short"><code>tag!(&amp;[T]: nom::AsBytes) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
declares a byte array as a suite to recognize</div></li><li><div class="item-name"><a class="macro" href="macro.tag_bits.html" title="macro nom::tag_bits">tag_bits</a></div><div class="desc docblock-short">Matches the given bit pattern.</div></li><li><div class="item-name"><a class="macro" href="macro.tag_no_case.html" title="macro nom::tag_no_case">tag_no_case</a></div><div class="desc docblock-short"><code>tag_no_case!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
declares a case insensitive ascii string as a suite to recognize</div></li><li><div class="item-name"><a class="macro" href="macro.tag_no_case_s.html" title="macro nom::tag_no_case_s">tag_no_case_s</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short"><code>tag_no_case_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
declares a case-insensitive string as a suite to recognize</div></li><li><div class="item-name"><a class="macro" href="macro.tag_s.html" title="macro nom::tag_s">tag_s</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short"><code>tag_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
declares a string as a suite to recognize</div></li><li><div class="item-name"><a class="macro" href="macro.take.html" title="macro nom::take">take</a></div><div class="desc docblock-short"><code>take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming the specified number of bytes</div></li><li><div class="item-name"><a class="macro" href="macro.take_bits.html" title="macro nom::take_bits">take_bits</a></div><div class="desc docblock-short">Consumes the specified number of bits and returns them as the specified type.</div></li><li><div class="item-name"><a class="macro" href="macro.take_s.html" title="macro nom::take_s">take_s</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short"><code>take_s!(nb) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming the specified number of characters</div></li><li><div class="item-name"><a class="macro" href="macro.take_str.html" title="macro nom::take_str">take_str</a></div><div class="desc docblock-short"><code>take_str!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;str&gt;</code>
same as take! but returning a &amp;str</div></li><li><div class="item-name"><a class="macro" href="macro.take_till.html" title="macro nom::take_till">take_till</a></div><div class="desc docblock-short"><code>take_till!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes until the provided function succeeds</div></li><li><div class="item-name"><a class="macro" href="macro.take_till1.html" title="macro nom::take_till1">take_till1</a></div><div class="desc docblock-short"><code>take_till1!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest non empty list of bytes until the provided function succeeds</div></li><li><div class="item-name"><a class="macro" href="macro.take_till1_s.html" title="macro nom::take_till1_s">take_till1_s</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short"><code>take_till1_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest non empty list of characters until the provided function succeeds</div></li><li><div class="item-name"><a class="macro" href="macro.take_till_s.html" title="macro nom::take_till_s">take_till_s</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short"><code>take_till_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters until the provided function succeeds</div></li><li><div class="item-name"><a class="macro" href="macro.take_until.html" title="macro nom::take_until">take_until</a></div><div class="desc docblock-short"><code>take_until!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds the specified tag.</div></li><li><div class="item-name"><a class="macro" href="macro.take_until1.html" title="macro nom::take_until1">take_until1</a></div><div class="desc docblock-short"><code>take_until1!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data (at least one byte) until it finds the specified tag</div></li><li><div class="item-name"><a class="macro" href="macro.take_until_and_consume.html" title="macro nom::take_until_and_consume">take_until_and_consume</a></div><div class="desc docblock-short"><code>take_until_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming bytes until the specified byte sequence is found, and consumes it</div></li><li><div class="item-name"><a class="macro" href="macro.take_until_and_consume1.html" title="macro nom::take_until_and_consume1">take_until_and_consume1</a></div><div class="desc docblock-short"><code>take_until_and_consume1!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming bytes (at least 1) until the specified byte sequence is found, and consumes it</div></li><li><div class="item-name"><a class="macro" href="macro.take_until_and_consume_s.html" title="macro nom::take_until_and_consume_s">take_until_and_consume_s</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short"><code>take_until_and_consume_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming all chars until the specified string is found and consumes it</div></li><li><div class="item-name"><a class="macro" href="macro.take_until_either.html" title="macro nom::take_until_either">take_until_either</a></div><div class="desc docblock-short"><code>take_until_either!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds any of the specified characters</div></li><li><div class="item-name"><a class="macro" href="macro.take_until_either1.html" title="macro nom::take_until_either1">take_until_either1</a></div><div class="desc docblock-short"><code>take_until_either1!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data (at least one byte) until it finds any of the specified characters</div></li><li><div class="item-name"><a class="macro" href="macro.take_until_either_and_consume.html" title="macro nom::take_until_either_and_consume">take_until_either_and_consume</a></div><div class="desc docblock-short"><code>take_until_either_and_consume!(chars) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds any of the specified characters, and consume it</div></li><li><div class="item-name"><a class="macro" href="macro.take_until_either_and_consume1.html" title="macro nom::take_until_either_and_consume1">take_until_either_and_consume1</a></div><div class="desc docblock-short"><code>take_until_either_and_consume1!(chars) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data (at least one byte) until it finds any of the specified characters, and consume it</div></li><li><div class="item-name"><a class="macro" href="macro.take_until_s.html" title="macro nom::take_until_s">take_until_s</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short"><code>take_until_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming all chars until the specified string is found and leaves it in the remaining input</div></li><li><div class="item-name"><a class="macro" href="macro.take_while.html" title="macro nom::take_while">take_while</a></div><div class="desc docblock-short"><code>take_while!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes until the provided function fails.</div></li><li><div class="item-name"><a class="macro" href="macro.take_while1.html" title="macro nom::take_while1">take_while1</a></div><div class="desc docblock-short"><code>take_while1!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest (non empty) list of bytes until the provided function fails.</div></li><li><div class="item-name"><a class="macro" href="macro.take_while1_s.html" title="macro nom::take_while1_s">take_while1_s</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short"><code>take_while1_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest (non empty) list of characters until the provided function fails.</div></li><li><div class="item-name"><a class="macro" href="macro.take_while_m_n.html" title="macro nom::take_while_m_n">take_while_m_n</a></div><div class="desc docblock-short"><code>take_while_m_n!(m: usize, n: usize, T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns a list of bytes or characters for which the provided function returns true.
the returned list’s size will be at least m, and at most n</div></li><li><div class="item-name"><a class="macro" href="macro.take_while_s.html" title="macro nom::take_while_s">take_while_s</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short"><code>take_while_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters until the provided function fails.</div></li><li><div class="item-name"><a class="macro" href="macro.tap.html" title="macro nom::tap">tap</a></div><div class="desc docblock-short"><code>tap!(name: I -&gt; IResult&lt;I,O&gt; =&gt; { block }) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
allows access to the parser’s result without affecting it</div></li><li><div class="item-name"><a class="macro" href="macro.terminated.html" title="macro nom::terminated">terminated</a></div><div class="desc docblock-short"><code>terminated!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,T&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
terminated(X, closing) returns X</div></li><li><div class="item-name"><a class="macro" href="macro.try_parse.html" title="macro nom::try_parse">try_parse</a></div><div class="desc docblock-short">A bit like <code>std::try!</code>, this macro will return the remaining input and
parsed value if the child parser returned <code>Ok</code>, and will do an early
return for the <code>Err</code> side.</div></li><li><div class="item-name"><a class="macro" href="macro.tuple.html" title="macro nom::tuple">tuple</a></div><div class="desc docblock-short"><code>tuple!(I-&gt;IResult&lt;I,A&gt;, I-&gt;IResult&lt;I,B&gt;, ... I-&gt;IResult&lt;I,X&gt;) =&gt; I -&gt; IResult&lt;I, (A, B, ..., X)&gt;</code>
chains parsers and assemble the sub results in a tuple.</div></li><li><div class="item-name"><a class="macro" href="macro.u16.html" title="macro nom::u16">u16</a></div><div class="desc docblock-short">if the parameter is nom::Endianness::Big, parse a big endian u16 integer,
otherwise a little endian u16 integer</div></li><li><div class="item-name"><a class="macro" href="macro.u32.html" title="macro nom::u32">u32</a></div><div class="desc docblock-short">if the parameter is nom::Endianness::Big, parse a big endian u32 integer,
otherwise a little endian u32 integer</div></li><li><div class="item-name"><a class="macro" href="macro.u64.html" title="macro nom::u64">u64</a></div><div class="desc docblock-short">if the parameter is nom::Endianness::Big, parse a big endian u64 integer,
otherwise a little endian u64 integer</div></li><li><div class="item-name"><a class="macro" href="macro.u128.html" title="macro nom::u128">u128</a></div><div class="desc docblock-short">if the parameter is nom::Endianness::Big, parse a big endian u128 integer,
otherwise a little endian u128 integer</div></li><li><div class="item-name"><a class="macro" href="macro.value.html" title="macro nom::value">value</a></div><div class="desc docblock-short"><code>value!(T, R -&gt; IResult&lt;R, S&gt; ) =&gt; R -&gt; IResult&lt;R, T&gt;</code></div></li><li><div class="item-name"><a class="macro" href="macro.verify.html" title="macro nom::verify">verify</a></div><div class="desc docblock-short"><code>verify!(I -&gt; IResult&lt;I,O&gt;, O -&gt; bool) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns the result of the child parser if it satisfies a verification function</div></li><li><div class="item-name"><a class="macro" href="macro.wrap_sep.html" title="macro nom::wrap_sep">wrap_sep</a></div></li><li><div class="item-name"><a class="macro" href="macro.ws.html" title="macro nom::ws">ws</a></div><div class="desc docblock-short"><code>ws!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code></div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.CompareResult.html" title="enum nom::CompareResult">CompareResult</a></div><div class="desc docblock-short">indicates wether a comparison was successful, an error, or
if more data was needed</div></li><li><div class="item-name"><a class="enum" href="enum.Endianness.html" title="enum nom::Endianness">Endianness</a></div><div class="desc docblock-short">Configurable endianness</div></li><li><div class="item-name"><a class="enum" href="enum.Err.html" title="enum nom::Err">Err</a></div><div class="desc docblock-short">The <code>Err</code> enum indicates the parser was not successful</div></li><li><div class="item-name"><a class="enum" href="enum.ErrorKind.html" title="enum nom::ErrorKind">ErrorKind</a></div><div class="desc docblock-short">indicates which parser returned an error</div></li><li><div class="item-name"><a class="enum" href="enum.Needed.html" title="enum nom::Needed">Needed</a></div><div class="desc docblock-short">Contains information on needed data if a parser returned <code>Incomplete</code></div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.AsBytes.html" title="trait nom::AsBytes">AsBytes</a></div><div class="desc docblock-short">casts the input type to a byte slice</div></li><li><div class="item-name"><a class="trait" href="trait.AsChar.html" title="trait nom::AsChar">AsChar</a></div><div class="desc docblock-short">transforms common types to a char for basic token parsing</div></li><li><div class="item-name"><a class="trait" href="trait.AtEof.html" title="trait nom::AtEof">AtEof</a></div><div class="desc docblock-short">indicates whether more data can come later in input</div></li><li><div class="item-name"><a class="trait" href="trait.Compare.html" title="trait nom::Compare">Compare</a></div><div class="desc docblock-short">abstracts comparison operations</div></li><li><div class="item-name"><a class="trait" href="trait.Convert.html" title="trait nom::Convert">Convert</a></div></li><li><div class="item-name"><a class="trait" href="trait.ExtendInto.html" title="trait nom::ExtendInto">ExtendInto</a></div><div class="desc docblock-short">abtracts something which can extend an <code>Extend</code></div></li><li><div class="item-name"><a class="trait" href="trait.FindSubstring.html" title="trait nom::FindSubstring">FindSubstring</a></div><div class="desc docblock-short">look for a substring in self</div></li><li><div class="item-name"><a class="trait" href="trait.FindToken.html" title="trait nom::FindToken">FindToken</a></div><div class="desc docblock-short">look for self in the given input stream</div></li><li><div class="item-name"><a class="trait" href="trait.HexDisplay.html" title="trait nom::HexDisplay">HexDisplay</a></div></li><li><div class="item-name"><a class="trait" href="trait.InputIter.html" title="trait nom::InputIter">InputIter</a></div><div class="desc docblock-short">abstracts common iteration operations on the input type</div></li><li><div class="item-name"><a class="trait" href="trait.InputLength.html" title="trait nom::InputLength">InputLength</a></div><div class="desc docblock-short">abstract method to calculate the input length</div></li><li><div class="item-name"><a class="trait" href="trait.InputTake.html" title="trait nom::InputTake">InputTake</a></div><div class="desc docblock-short">abstracts slicing operations</div></li><li><div class="item-name"><a class="trait" href="trait.InputTakeAtPosition.html" title="trait nom::InputTakeAtPosition">InputTakeAtPosition</a></div><div class="desc docblock-short">methods to take as much input as possible until the provided function returns true for the current element</div></li><li><div class="item-name"><a class="trait" href="trait.Offset.html" title="trait nom::Offset">Offset</a></div><div class="desc docblock-short">useful functions to calculate the offset between slices and show a hexdump of a slice</div></li><li><div class="item-name"><a class="trait" href="trait.ParseTo.html" title="trait nom::ParseTo">ParseTo</a></div><div class="desc docblock-short">used to integrate str’s parse() method</div></li><li><div class="item-name"><a class="trait" href="trait.Slice.html" title="trait nom::Slice">Slice</a></div><div class="desc docblock-short">slicing operations using ranges</div></li><li><div class="item-name"><a class="trait" href="trait.UnspecializedInput.html" title="trait nom::UnspecializedInput">UnspecializedInput</a></div><div class="desc docblock-short">Dummy trait used for default implementations (currently only used for <code>InputTakeAtPosition</code>).</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.alpha.html" title="fn nom::alpha">alpha</a></div><div class="desc docblock-short">Recognizes one or more lowercase and uppercase alphabetic characters.
For ASCII strings: a-zA-Z
For UTF8 strings, any alphabetic code point (ie, not only the ASCII ones)</div></li><li><div class="item-name"><a class="fn" href="fn.alpha0.html" title="fn nom::alpha0">alpha0</a></div><div class="desc docblock-short">Recognizes zero or more lowercase and uppercase alphabetic characters.
For ASCII strings: a-zA-Z
For UTF8 strings, any alphabetic code point (ie, not only the ASCII ones)</div></li><li><div class="item-name"><a class="fn" href="fn.alpha1.html" title="fn nom::alpha1">alpha1</a></div><div class="desc docblock-short">Recognizes one or more lowercase and uppercase alphabetic characters
For ASCII strings: a-zA-Z
For UTF8 strings, any alphabetic code point (ie, not only the ASCII ones)</div></li><li><div class="item-name"><a class="fn" href="fn.alphanumeric.html" title="fn nom::alphanumeric">alphanumeric</a></div><div class="desc docblock-short">Recognizes one or more numerical and alphabetic characters
For ASCII strings: 0-9a-zA-Z
For UTF8 strings, 0-9 and any alphabetic code point (ie, not only the ASCII ones)</div></li><li><div class="item-name"><a class="fn" href="fn.alphanumeric0.html" title="fn nom::alphanumeric0">alphanumeric0</a></div><div class="desc docblock-short">Recognizes zero or more numerical and alphabetic characters.
For ASCII strings: 0-9a-zA-Z
For UTF8 strings, 0-9 and any alphabetic code point (ie, not only the ASCII ones)</div></li><li><div class="item-name"><a class="fn" href="fn.alphanumeric1.html" title="fn nom::alphanumeric1">alphanumeric1</a></div><div class="desc docblock-short">Recognizes one or more numerical and alphabetic characters.
For ASCII strings: 0-9a-zA-Z
For UTF8 strings, 0-9 and any alphabetic code point (ie, not only the ASCII ones)</div></li><li><div class="item-name"><a class="fn" href="fn.anychar.html" title="fn nom::anychar">anychar</a></div><div class="desc docblock-short">matches one byte as a character. Note that the input type will
accept a <code>str</code>, but not a <code>&amp;[u8]</code>, unlike many other nom parsers.</div></li><li><div class="item-name"><a class="fn" href="fn.be_f32.html" title="fn nom::be_f32">be_f32</a></div><div class="desc docblock-short">Recognizes big endian 4 bytes floating point number</div></li><li><div class="item-name"><a class="fn" href="fn.be_f64.html" title="fn nom::be_f64">be_f64</a></div><div class="desc docblock-short">Recognizes big endian 8 bytes floating point number</div></li><li><div class="item-name"><a class="fn" href="fn.be_i8.html" title="fn nom::be_i8">be_i8</a></div><div class="desc docblock-short">Recognizes a signed 1 byte integer (equivalent to take!(1)</div></li><li><div class="item-name"><a class="fn" href="fn.be_i16.html" title="fn nom::be_i16">be_i16</a></div><div class="desc docblock-short">Recognizes big endian signed 2 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.be_i24.html" title="fn nom::be_i24">be_i24</a></div><div class="desc docblock-short">Recognizes big endian signed 3 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.be_i32.html" title="fn nom::be_i32">be_i32</a></div><div class="desc docblock-short">Recognizes big endian signed 4 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.be_i64.html" title="fn nom::be_i64">be_i64</a></div><div class="desc docblock-short">Recognizes big endian signed 8 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.be_i128.html" title="fn nom::be_i128">be_i128</a></div><div class="desc docblock-short">Recognizes big endian signed 16 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.be_u8.html" title="fn nom::be_u8">be_u8</a></div><div class="desc docblock-short">Recognizes an unsigned 1 byte integer (equivalent to take!(1)</div></li><li><div class="item-name"><a class="fn" href="fn.be_u16.html" title="fn nom::be_u16">be_u16</a></div><div class="desc docblock-short">Recognizes big endian unsigned 2 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.be_u24.html" title="fn nom::be_u24">be_u24</a></div><div class="desc docblock-short">Recognizes big endian unsigned 3 byte integer</div></li><li><div class="item-name"><a class="fn" href="fn.be_u32.html" title="fn nom::be_u32">be_u32</a></div><div class="desc docblock-short">Recognizes big endian unsigned 4 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.be_u64.html" title="fn nom::be_u64">be_u64</a></div><div class="desc docblock-short">Recognizes big endian unsigned 8 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.be_u128.html" title="fn nom::be_u128">be_u128</a></div><div class="desc docblock-short">Recognizes big endian unsigned 16 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.begin.html" title="fn nom::begin">begin</a></div></li><li><div class="item-name"><a class="fn" href="fn.code_from_offset.html" title="fn nom::code_from_offset">code_from_offset</a></div></li><li><div class="item-name"><a class="fn" href="fn.crlf.html" title="fn nom::crlf">crlf</a></div></li><li><div class="item-name"><a class="fn" href="fn.digit.html" title="fn nom::digit">digit</a></div><div class="desc docblock-short">Recognizes one or more numerical characters: 0-9</div></li><li><div class="item-name"><a class="fn" href="fn.digit0.html" title="fn nom::digit0">digit0</a></div><div class="desc docblock-short">Recognizes zero or more numerical characters: 0-9</div></li><li><div class="item-name"><a class="fn" href="fn.digit1.html" title="fn nom::digit1">digit1</a></div><div class="desc docblock-short">Recognizes one or more numerical characters: 0-9</div></li><li><div class="item-name"><a class="fn" href="fn.double.html" title="fn nom::double">double</a></div><div class="desc docblock-short">Recognizes floating point number in a byte string and returns a f64</div></li><li><div class="item-name"><a class="fn" href="fn.double_s.html" title="fn nom::double_s">double_s</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">Recognizes floating point number in a string and returns a f64</div></li><li><div class="item-name"><a class="fn" href="fn.eol.html" title="fn nom::eol">eol</a></div></li><li><div class="item-name"><a class="fn" href="fn.error_to_u32.html" title="fn nom::error_to_u32">error_to_u32</a></div></li><li><div class="item-name"><a class="fn" href="fn.float.html" title="fn nom::float">float</a></div><div class="desc docblock-short">Recognizes floating point number in a byte string and returns a f32</div></li><li><div class="item-name"><a class="fn" href="fn.float_s.html" title="fn nom::float_s">float_s</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">Recognizes floating point number in a string and returns a f32</div></li><li><div class="item-name"><a class="fn" href="fn.hex_digit.html" title="fn nom::hex_digit">hex_digit</a></div><div class="desc docblock-short">Recognizes one or more hexadecimal numerical characters: 0-9, A-F, a-f</div></li><li><div class="item-name"><a class="fn" href="fn.hex_digit0.html" title="fn nom::hex_digit0">hex_digit0</a></div><div class="desc docblock-short">Recognizes zero or more hexadecimal numerical characters: 0-9, A-F, a-f</div></li><li><div class="item-name"><a class="fn" href="fn.hex_digit1.html" title="fn nom::hex_digit1">hex_digit1</a></div><div class="desc docblock-short">Recognizes one or more hexadecimal numerical characters: 0-9, A-F, a-f</div></li><li><div class="item-name"><a class="fn" href="fn.hex_u32.html" title="fn nom::hex_u32">hex_u32</a></div><div class="desc docblock-short">Recognizes a hex-encoded integer</div></li><li><div class="item-name"><a class="fn" href="fn.is_alphabetic.html" title="fn nom::is_alphabetic">is_alphabetic</a></div><div class="desc docblock-short">Tests if byte is ASCII alphabetic: A-Z, a-z</div></li><li><div class="item-name"><a class="fn" href="fn.is_alphanumeric.html" title="fn nom::is_alphanumeric">is_alphanumeric</a></div><div class="desc docblock-short">Tests if byte is ASCII alphanumeric: A-Z, a-z, 0-9</div></li><li><div class="item-name"><a class="fn" href="fn.is_digit.html" title="fn nom::is_digit">is_digit</a></div><div class="desc docblock-short">Tests if byte is ASCII digit: 0-9</div></li><li><div class="item-name"><a class="fn" href="fn.is_hex_digit.html" title="fn nom::is_hex_digit">is_hex_digit</a></div><div class="desc docblock-short">Tests if byte is ASCII hex digit: 0-9, A-F, a-f</div></li><li><div class="item-name"><a class="fn" href="fn.is_oct_digit.html" title="fn nom::is_oct_digit">is_oct_digit</a></div><div class="desc docblock-short">Tests if byte is ASCII octal digit: 0-7</div></li><li><div class="item-name"><a class="fn" href="fn.is_space.html" title="fn nom::is_space">is_space</a></div><div class="desc docblock-short">Tests if byte is ASCII space or tab</div></li><li><div class="item-name"><a class="fn" href="fn.le_f32.html" title="fn nom::le_f32">le_f32</a></div><div class="desc docblock-short">Recognizes little endian 4 bytes floating point number</div></li><li><div class="item-name"><a class="fn" href="fn.le_f64.html" title="fn nom::le_f64">le_f64</a></div><div class="desc docblock-short">Recognizes little endian 8 bytes floating point number</div></li><li><div class="item-name"><a class="fn" href="fn.le_i8.html" title="fn nom::le_i8">le_i8</a></div><div class="desc docblock-short">Recognizes a signed 1 byte integer (equivalent to take!(1)</div></li><li><div class="item-name"><a class="fn" href="fn.le_i16.html" title="fn nom::le_i16">le_i16</a></div><div class="desc docblock-short">Recognizes little endian signed 2 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.le_i24.html" title="fn nom::le_i24">le_i24</a></div><div class="desc docblock-short">Recognizes little endian signed 3 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.le_i32.html" title="fn nom::le_i32">le_i32</a></div><div class="desc docblock-short">Recognizes little endian signed 4 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.le_i64.html" title="fn nom::le_i64">le_i64</a></div><div class="desc docblock-short">Recognizes little endian signed 8 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.le_i128.html" title="fn nom::le_i128">le_i128</a></div><div class="desc docblock-short">Recognizes little endian signed 16 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.le_u8.html" title="fn nom::le_u8">le_u8</a></div><div class="desc docblock-short">Recognizes an unsigned 1 byte integer (equivalent to take!(1)</div></li><li><div class="item-name"><a class="fn" href="fn.le_u16.html" title="fn nom::le_u16">le_u16</a></div><div class="desc docblock-short">Recognizes little endian unsigned 2 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.le_u24.html" title="fn nom::le_u24">le_u24</a></div><div class="desc docblock-short">Recognizes little endian unsigned 3 byte integer</div></li><li><div class="item-name"><a class="fn" href="fn.le_u32.html" title="fn nom::le_u32">le_u32</a></div><div class="desc docblock-short">Recognizes little endian unsigned 4 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.le_u64.html" title="fn nom::le_u64">le_u64</a></div><div class="desc docblock-short">Recognizes little endian unsigned 8 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.le_u128.html" title="fn nom::le_u128">le_u128</a></div><div class="desc docblock-short">Recognizes little endian unsigned 16 bytes integer</div></li><li><div class="item-name"><a class="fn" href="fn.line_ending.html" title="fn nom::line_ending">line_ending</a></div><div class="desc docblock-short">Recognizes an end of line (both ‘\n’ and ‘\r\n’)</div></li><li><div class="item-name"><a class="fn" href="fn.multispace.html" title="fn nom::multispace">multispace</a></div><div class="desc docblock-short">Recognizes one or more spaces, tabs, carriage returns and line feeds</div></li><li><div class="item-name"><a class="fn" href="fn.multispace0.html" title="fn nom::multispace0">multispace0</a></div><div class="desc docblock-short">Recognizes zero or more spaces, tabs, carriage returns and line feeds</div></li><li><div class="item-name"><a class="fn" href="fn.multispace1.html" title="fn nom::multispace1">multispace1</a></div><div class="desc docblock-short">Recognizes one or more spaces, tabs, carriage returns and line feeds</div></li><li><div class="item-name"><a class="fn" href="fn.need_more.html" title="fn nom::need_more">need_more</a></div></li><li><div class="item-name"><a class="fn" href="fn.need_more_err.html" title="fn nom::need_more_err">need_more_err</a></div></li><li><div class="item-name"><a class="fn" href="fn.newline.html" title="fn nom::newline">newline</a></div><div class="desc docblock-short">Matches a newline character ‘\n’</div></li><li><div class="item-name"><a class="fn" href="fn.non_empty.html" title="fn nom::non_empty">non_empty</a></div><div class="desc docblock-short">Recognizes non empty buffers</div></li><li><div class="item-name"><a class="fn" href="fn.not_line_ending.html" title="fn nom::not_line_ending">not_line_ending</a></div></li><li><div class="item-name"><a class="fn" href="fn.oct_digit.html" title="fn nom::oct_digit">oct_digit</a></div><div class="desc docblock-short">Recognizes one or more octal characters: 0-7</div></li><li><div class="item-name"><a class="fn" href="fn.oct_digit0.html" title="fn nom::oct_digit0">oct_digit0</a></div><div class="desc docblock-short">Recognizes zero or more octal characters: 0-7</div></li><li><div class="item-name"><a class="fn" href="fn.oct_digit1.html" title="fn nom::oct_digit1">oct_digit1</a></div><div class="desc docblock-short">Recognizes one or more octal characters: 0-7</div></li><li><div class="item-name"><a class="fn" href="fn.print.html" title="fn nom::print">print</a></div></li><li><div class="item-name"><a class="fn" href="fn.print_codes.html" title="fn nom::print_codes">print_codes</a></div></li><li><div class="item-name"><a class="fn" href="fn.recognize_float.html" title="fn nom::recognize_float">recognize_float</a></div></li><li><div class="item-name"><a class="fn" href="fn.reset_color.html" title="fn nom::reset_color">reset_color</a></div></li><li><div class="item-name"><a class="fn" href="fn.rest.html" title="fn nom::rest">rest</a></div><div class="desc docblock-short">Return the remaining input.</div></li><li><div class="item-name"><a class="fn" href="fn.rest_len.html" title="fn nom::rest_len">rest_len</a></div><div class="desc docblock-short">Return the length of the remaining input.</div></li><li><div class="item-name"><a class="fn" href="fn.rest_s.html" title="fn nom::rest_s">rest_s</a></div><div class="desc docblock-short">Return the remaining input, for strings.</div></li><li><div class="item-name"><a class="fn" href="fn.sized_buffer.html" title="fn nom::sized_buffer">sized_buffer</a></div></li><li><div class="item-name"><a class="fn" href="fn.slice_to_offsets.html" title="fn nom::slice_to_offsets">slice_to_offsets</a></div></li><li><div class="item-name"><a class="fn" href="fn.space.html" title="fn nom::space">space</a></div><div class="desc docblock-short">Recognizes one or more spaces and tabs</div></li><li><div class="item-name"><a class="fn" href="fn.space0.html" title="fn nom::space0">space0</a></div><div class="desc docblock-short">Recognizes zero or more spaces and tabs</div></li><li><div class="item-name"><a class="fn" href="fn.space1.html" title="fn nom::space1">space1</a></div><div class="desc docblock-short">Recognizes one or more spaces and tabs</div></li><li><div class="item-name"><a class="fn" href="fn.tab.html" title="fn nom::tab">tab</a></div><div class="desc docblock-short">Matches a tab character ‘\t’</div></li><li><div class="item-name"><a class="fn" href="fn.tag_cl.html" title="fn nom::tag_cl">tag_cl</a></div></li><li><div class="item-name"><a class="fn" href="fn.write_color.html" title="fn nom::write_color">write_color</a></div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.IResult.html" title="type nom::IResult">IResult</a></div><div class="desc docblock-short">Holds the result of parsing functions</div></li></ul></section></div></main></body></html>