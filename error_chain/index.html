<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A library for consistent and reliable error handling"><title>error_chain - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="error_chain" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.0 (8ede3aae2 2023-07-12)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../error_chain/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../error_chain/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate error_chain</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.10.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">error_chain</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/error_chain/lib.rs.html#1-659">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A library for consistent and reliable error handling</p>
<p>error-chain makes it easy to take full advantage of Rust’s
powerful error handling features without the overhead of
maintaining boilerplate error types and conversions. It implements
an opinionated strategy for defining your own error types, as well
as conversions from others’ error types.</p>
<h3 id="quick-start"><a href="#quick-start">Quick start</a></h3>
<p>If you just want to set up your new project with error-chain,
follow the <a href="https://github.com/brson/error-chain/blob/master/examples/quickstart.rs">quickstart.rs</a> template, and read this <a href="http://brson.github.io/2016/11/30/starting-with-error-chain">intro</a>
to error-chain.</p>
<h3 id="why-error-chain"><a href="#why-error-chain">Why error chain?</a></h3>
<ul>
<li>error-chain is easy to configure. Handle errors robustly with minimal
effort.</li>
<li>Basic error handling requires no maintenance of custom error types
nor the <code>From</code> conversions that make <code>?</code> work.</li>
<li>error-chain scales from simple error handling strategies to more
rigorous.  Return formatted strings for simple errors, only
introducing error variants and their strong typing as needed for
advanced error recovery.</li>
<li>error-chain makes it trivial to correctly manage the <a href="https://doc.rust-lang.org/std/error/trait.Error.html#method.cause">cause</a> of
the errors generated by your own code. This is the “chaining”
in “error-chain”.</li>
</ul>
<h3 id="principles-of-error-chain"><a href="#principles-of-error-chain">Principles of error-chain</a></h3>
<p>error-chain is based on the following principles:</p>
<ul>
<li>No error should ever be discarded. This library primarily
makes it easy to “chain” errors with the <code>chain_err</code> method.</li>
<li>Introducing new errors is trivial. Simple errors can be introduced
at the error site with just a string.</li>
<li>Handling errors is possible with pattern matching.</li>
<li>Conversions between error types are done in an automatic and
consistent way - <code>From</code> conversion behavior is never specified
explicitly.</li>
<li>Errors implement Send.</li>
<li>Errors can carry backtraces.</li>
</ul>
<p>Similar to other libraries like <a href="https://github.com/DanielKeep/rust-error-type">error-type</a> and <a href="https://github.com/tailhook/quick-error">quick-error</a>,
this library introduces the error chaining mechanism originally
employed by Cargo.  The <code>error_chain!</code> macro declares the types
and implementation boilerplate necessary for fulfilling a
particular error-handling strategy. Most importantly it defines a
custom error type (called <code>Error</code> by convention) and the <code>From</code>
conversions that let the <code>try!</code> macro and <code>?</code> operator work.</p>
<p>This library differs in a few ways from previous error libs:</p>
<ul>
<li>Instead of defining the custom <code>Error</code> type as an enum, it is a
struct containing an <code>ErrorKind</code> (which defines the
<code>description</code> and <code>display</code> methods for the error), an opaque,
optional, boxed <code>std::error::Error + Send + 'static</code> object
(which defines the <code>cause</code>, and establishes the links in the
error chain), and a <code>Backtrace</code>.</li>
<li>The macro also defines a <code>ResultExt</code> trait that defines a
<code>chain_err</code> method. This method on all <code>std::error::Error + Send + 'static</code>
types extends the error chain by boxing the current
error into an opaque object and putting it inside a new concrete
error.</li>
<li>It provides automatic <code>From</code> conversions between other error types
defined by the <code>error_chain!</code> that preserve type information,
and facilitate seamless error composition and matching of composed
errors.</li>
<li>It provides automatic <code>From</code> conversions between any other error
type that hides the type of the other error in the <code>cause</code> box.</li>
<li>If <code>RUST_BACKTRACE</code> is enabled, it collects a single backtrace at
the earliest opportunity and propagates it down the stack through
<code>From</code> and <code>ResultExt</code> conversions.</li>
</ul>
<p>To accomplish its goals it makes some tradeoffs:</p>
<ul>
<li>The split between the <code>Error</code> and <code>ErrorKind</code> types can make it
slightly more cumbersome to instantiate new (unchained) errors,
requiring an <code>Into</code> or <code>From</code> conversion; as well as slightly
more cumbersome to match on errors with another layer of types
to match.</li>
<li>Because the error type contains <code>std::error::Error + Send + 'static</code> objects,
it can’t implement <code>PartialEq</code> for easy comparisons.</li>
</ul>
<h3 id="declaring-error-types"><a href="#declaring-error-types">Declaring error types</a></h3>
<p>Generally, you define one family of error types per crate, though
it’s also perfectly fine to define error types on a finer-grained
basis, such as per module.</p>
<p>Assuming you are using crate-level error types, typically you will
define an <code>errors</code> module and inside it call <code>error_chain!</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">mod </span>other_error {
    <span class="macro">error_chain! </span>{}
}

<span class="macro">error_chain! </span>{
    <span class="comment">// The type defined for this error. These are the conventional
    // and recommended names, but they can be arbitrarily chosen.
    //
    // It is also possible to leave this section out entirely, or
    // leave it empty, and these names will be used automatically.
    </span>types {
        Error, ErrorKind, ResultExt, <span class="prelude-ty">Result</span>;
    }

    <span class="comment">// Without the `Result` wrapper:
    //
    // types {
    //     Error, ErrorKind, ResultExt;
    // }

    // Automatic conversions between this error chain and other
    // error chains. In this case, it will e.g. generate an
    // `ErrorKind` variant called `Another` which in turn contains
    // the `other_error::ErrorKind`, with conversions from
    // `other_error::Error`.
    //
    // Optionally, some attributes can be added to a variant.
    //
    // This section can be empty.
    </span>links {
        Another(other_error::Error, other_error::ErrorKind) <span class="attr">#[cfg(unix)]</span>;
    }

    <span class="comment">// Automatic conversions between this error chain and other
    // error types not defined by the `error_chain!`. These will be
    // wrapped in a new error with, in the first case, the
    // `ErrorKind::Fmt` variant. The description and cause will
    // forward to the description and cause of the original error.
    //
    // Optionally, some attributes can be added to a variant.
    //
    // This section can be empty.
    </span>foreign_links {
        Fmt(::std::fmt::Error);
        Io(::std::io::Error) <span class="attr">#[cfg(unix)]</span>;
    }

    <span class="comment">// Define additional `ErrorKind` variants. The syntax here is
    // the same as `quick_error!`, but the `from()` and `cause()`
    // syntax is not supported.
    </span>errors {
        InvalidToolchainName(t: String) {
            description(<span class="string">&quot;invalid toolchain name&quot;</span>)
            display(<span class="string">&quot;invalid toolchain name: &#39;{}&#39;&quot;</span>, t)
        }
    }
}
</code></pre></div>
<p>Each section, <code>types</code>, <code>links</code>, <code>foreign_links</code>, and <code>errors</code> may
be omitted if it is empty.</p>
<p>This populates the module with a number of definitions,
the most important of which are the <code>Error</code> type
and the <code>ErrorKind</code> type. An example of generated code can be found in the
<a href="example_generated/index.html" title="mod error_chain::example_generated">example_generated</a> module.</p>
<h3 id="returning-new-errors"><a href="#returning-new-errors">Returning new errors</a></h3>
<p>Introducing new error chains, with a string message:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>foo() -&gt; <span class="prelude-ty">Result</span>&lt;()&gt; {
    <span class="prelude-val">Err</span>(<span class="string">&quot;foo error!&quot;</span>.into())
}</code></pre></div>
<p>Introducing new error chains, with an <code>ErrorKind</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">error_chain! </span>{
    errors { FooError }
}

<span class="kw">fn </span>foo() -&gt; <span class="prelude-ty">Result</span>&lt;()&gt; {
    <span class="prelude-val">Err</span>(ErrorKind::FooError.into())
}</code></pre></div>
<p>Note that the return type is the typedef <code>Result</code>, which is
defined by the macro as <code>pub type Result&lt;T&gt; = ::std::result::Result&lt;T, Error&gt;</code>. Note that in both cases
<code>.into()</code> is called to convert a type into the <code>Error</code> type; both
strings and <code>ErrorKind</code> have <code>From</code> conversions to turn them into
<code>Error</code>.</p>
<p>When the error is emitted inside a <code>try!</code> macro or behind the
<code>?</code> operator, the explicit conversion isn’t needed; <code>try!</code> will
automatically convert <code>Err(ErrorKind)</code> to <code>Err(Error)</code>. So the
below is equivalent to the previous:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>foo() -&gt; <span class="prelude-ty">Result</span>&lt;()&gt; {
    <span class="prelude-val">Ok</span>(<span class="macro">try!</span>(<span class="prelude-val">Err</span>(ErrorKind::FooError)))
}

<span class="kw">fn </span>bar() -&gt; <span class="prelude-ty">Result</span>&lt;()&gt; {
    <span class="prelude-val">Ok</span>(<span class="macro">try!</span>(<span class="prelude-val">Err</span>(<span class="string">&quot;bogus!&quot;</span>)))
}</code></pre></div>
<h3 id="the-bail-macro"><a href="#the-bail-macro">The <code>bail!</code> macro</a></h3>
<p>The above method of introducing new errors works but is a little
verbose. Instead we can use the <code>bail!</code> macro, which, much like <code>try!</code>
and <code>?</code>, performs an early return with conversions. With <code>bail!</code> the
previous examples look like:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>foo() -&gt; <span class="prelude-ty">Result</span>&lt;()&gt; {
    <span class="kw">if </span><span class="bool-val">true </span>{
        <span class="macro">bail!</span>(ErrorKind::FooError);
    } <span class="kw">else </span>{
        <span class="prelude-val">Ok</span>(())
    }
}

<span class="kw">fn </span>bar() -&gt; <span class="prelude-ty">Result</span>&lt;()&gt; {
    <span class="kw">if </span><span class="bool-val">true </span>{
        <span class="macro">bail!</span>(<span class="string">&quot;bogus!&quot;</span>);
    } <span class="kw">else </span>{
        <span class="prelude-val">Ok</span>(())
    }
}</code></pre></div>
<h3 id="chaining-errors"><a href="#chaining-errors">Chaining errors</a></h3>
<p>To extend the error chain:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>res: <span class="prelude-ty">Result</span>&lt;()&gt; = do_something().chain_err(|| <span class="string">&quot;something went wrong&quot;</span>);</code></pre></div>
<p><code>chain_err</code> can be called on any <code>Result</code> type where the contained
error type implements <code>std::error::Error + Send + 'static</code>.  If
the <code>Result</code> is an <code>Err</code> then <code>chain_err</code> evaluates the closure,
which returns <em>some type that can be converted to <code>ErrorKind</code></em>,
boxes the original error to store as the cause, then returns a new
error containing the original error.</p>
<h3 id="matching-errors"><a href="#matching-errors">Matching errors</a></h3>
<p>error-chain error variants are matched with simple patterns.
<code>Error</code> is a tuple struct and its first field is the <code>ErrorKind</code>,
making dispatching on error kinds relatively compact:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">error_chain! </span>{
    errors {
        InvalidToolchainName(t: String) {
            description(<span class="string">&quot;invalid toolchain name&quot;</span>)
            display(<span class="string">&quot;invalid toolchain name: &#39;{}&#39;&quot;</span>, t)
        }
    }
}

<span class="kw">match </span>Error::from(<span class="string">&quot;error!&quot;</span>) {
    Error(ErrorKind::InvalidToolchainName(<span class="kw">_</span>), <span class="kw">_</span>) =&gt; { }
    Error(ErrorKind::Msg(<span class="kw">_</span>), <span class="kw">_</span>) =&gt; { }
}</code></pre></div>
<p>Chained errors are also matched with (relatively) compact syntax</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">mod </span>utils {
    <span class="macro">error_chain! </span>{
        errors {
            BadStuff {
                description(<span class="string">&quot;bad stuff&quot;</span>)
            }
        }
    }
}

<span class="kw">mod </span>app {
    <span class="macro">error_chain! </span>{
        links {
            Utils(::utils::Error, ::utils::ErrorKind);
        }
    }
}


<span class="kw">match </span>app::Error::from(<span class="string">&quot;error!&quot;</span>) {
    app::Error(app::ErrorKind::Utils(utils::ErrorKind::BadStuff), <span class="kw">_</span>) =&gt; { }
    <span class="kw">_ </span>=&gt; { }
}</code></pre></div>
<h3 id="foreign-links"><a href="#foreign-links">Foreign links</a></h3>
<p>Errors that do not conform to the same conventions as this library
can still be included in the error chain. They are considered “foreign
errors”, and are declared using the <code>foreign_links</code> block of the
<code>error_chain!</code> macro. <code>Error</code>s are automatically created from
foreign errors by the <code>try!</code> macro.</p>
<p>Foreign links and regular links have one crucial difference:
<code>From</code> conversions for regular links <em>do not introduce a new error
into the error chain</em>, while conversions for foreign links <em>always
introduce a new error into the error chain</em>. So for the example
above all errors deriving from the <code>temp::Error</code> type will be
presented to the user as a new <code>ErrorKind::Temp</code> variant, and the
cause will be the original <code>temp::Error</code> error. In contrast, when
<code>rustup_utils::Error</code> is converted to <code>Error</code> the two <code>ErrorKind</code>s
are converted between each other to create a new <code>Error</code> but the
old error is discarded; there is no “cause” created from the
original error.</p>
<h3 id="backtraces"><a href="#backtraces">Backtraces</a></h3>
<p>If the <code>RUST_BACKTRACE</code> environment variable is set to anything
but <code>0</code>, the earliest non-foreign error to be generated creates
a single backtrace, which is passed through all <code>From</code> conversions
and <code>chain_err</code> invocations of compatible types. To read the
backtrace just call the <code>backtrace()</code> method.</p>
<p>Backtrace generation can be disabled by turning off the <code>backtrace</code> feature.</p>
<h3 id="iteration"><a href="#iteration">Iteration</a></h3>
<p>The <code>iter</code> method returns an iterator over the chain of error boxes.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="example_generated/index.html" title="mod error_chain::example_generated">example_generated</a></div><div class="desc docblock-short">These modules show an example of code generated by the macro. <strong>IT MUST NOT BE
USED OUTSIDE THIS CRATE</strong>.</div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.bail.html" title="macro error_chain::bail">bail</a></div><div class="desc docblock-short">Exits a function early with an error</div></li><li><div class="item-name"><a class="macro" href="macro.ensure.html" title="macro error_chain::ensure">ensure</a></div><div class="desc docblock-short">Exits a function early with an error if the condition is not satisfied</div></li><li><div class="item-name"><a class="macro" href="macro.error_chain.html" title="macro error_chain::error_chain">error_chain</a></div><div class="desc docblock-short">This macro is used for handling of duplicated and out-of-order fields. For
the exact rules, see <code>error_chain_processed</code>.</div></li><li><div class="item-name"><a class="macro" href="macro.error_chain_processed.html" title="macro error_chain::error_chain_processed">error_chain_processed</a></div><div class="desc docblock-short">Prefer to use <code>error_chain</code> instead of this macro.</div></li><li><div class="item-name"><a class="macro" href="macro.quick_error.html" title="macro error_chain::quick_error">quick_error</a></div></li><li><div class="item-name"><a class="macro" href="macro.quick_main.html" title="macro error_chain::quick_main">quick_main</a></div><div class="desc docblock-short">Convenient wrapper to be able to use <code>try!</code> and such in the main. You can
use it with a separated function:</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Backtrace.html" title="struct error_chain::Backtrace">Backtrace</a></div><div class="desc docblock-short">Representation of an owned and self-contained backtrace.</div></li><li><div class="item-name"><a class="struct" href="struct.Display.html" title="struct error_chain::Display">Display</a></div><div class="desc docblock-short">A struct which formats an error for output.</div></li><li><div class="item-name"><a class="struct" href="struct.ErrorChainIter.html" title="struct error_chain::ErrorChainIter">ErrorChainIter</a></div><div class="desc docblock-short">Iterator over the error chain using the <code>Error::cause()</code> method.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.ChainedError.html" title="trait error_chain::ChainedError">ChainedError</a></div><div class="desc docblock-short">This trait is implemented on all the errors generated by the <code>error_chain</code>
macro.</div></li><li><div class="item-name"><a class="trait" href="trait.ExitCode.html" title="trait error_chain::ExitCode">ExitCode</a></div><div class="desc docblock-short">Represents a value that can be used as the exit status of the process.
See <a href="macro.quick_main.html"><code>quick_main!</code></a>.</div></li></ul></section></div></main></body></html>