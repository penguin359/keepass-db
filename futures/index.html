<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Zero-cost Futures in Rust"><title>futures - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="futures" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.0 (8ede3aae2 2023-07-12)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../futures/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../futures/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate futures</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.31</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#enums">Enums</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">futures</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/futures/lib.rs.html#1-266">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Zero-cost Futures in Rust</p>
<p>This library is an implementation of futures in Rust which aims to provide
a robust implementation of handling asynchronous computations, ergonomic
composition and usage, and zero-cost abstractions over what would otherwise
be written by hand.</p>
<p>Futures are a concept for an object which is a proxy for another value that
may not be ready yet. For example issuing an HTTP request may return a
future for the HTTP response, as it probably hasn’t arrived yet. With an
object representing a value that will eventually be available, futures allow
for powerful composition of tasks through basic combinators that can perform
operations like chaining computations, changing the types of futures, or
waiting for two futures to complete at the same time.</p>
<p>You can find extensive tutorials and documentations at <a href="https://tokio.rs">https://tokio.rs</a>
for both this crate (asynchronous programming in general) as well as the
Tokio stack to perform async I/O with.</p>
<h3 id="installation"><a href="#installation">Installation</a></h3>
<p>Add this to your <code>Cargo.toml</code>:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
futures = &quot;0.1&quot;
</code></pre></div><h3 id="examples"><a href="#examples">Examples</a></h3>
<p>Let’s take a look at a few examples of how futures might be used:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>futures;

<span class="kw">use </span>std::io;
<span class="kw">use </span>std::time::Duration;
<span class="kw">use </span>futures::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>futures::future::Map;

<span class="comment">// A future is actually a trait implementation, so we can generically take a
// future of any integer and return back a future that will resolve to that
// value plus 10 more.
//
// Note here that like iterators, we&#39;re returning the `Map` combinator in
// the futures crate, not a boxed abstraction. This is a zero-cost
// construction of a future.
</span><span class="kw">fn </span>add_ten&lt;F&gt;(future: F) -&gt; Map&lt;F, <span class="kw">fn</span>(i32) -&gt; i32&gt;
    <span class="kw">where </span>F: Future&lt;Item=i32&gt;,
{
    <span class="kw">fn </span>add(a: i32) -&gt; i32 { a + <span class="number">10 </span>}
    future.map(add)
}

<span class="comment">// Not only can we modify one future, but we can even compose them together!
// Here we have a function which takes two futures as input, and returns a
// future that will calculate the sum of their two values.
//
// Above we saw a direct return value of the `Map` combinator, but
// performance isn&#39;t always critical and sometimes it&#39;s more ergonomic to
// return a trait object like we do here. Note though that there&#39;s only one
// allocation here, not any for the intermediate futures.
</span><span class="kw">fn </span>add&lt;<span class="lifetime">&#39;a</span>, A, B&gt;(a: A, b: B) -&gt; Box&lt;Future&lt;Item=i32, Error=A::Error&gt; + <span class="lifetime">&#39;a</span>&gt;
    <span class="kw">where </span>A: Future&lt;Item=i32&gt; + <span class="lifetime">&#39;a</span>,
          B: Future&lt;Item=i32, Error=A::Error&gt; + <span class="lifetime">&#39;a</span>,
{
    Box::new(a.join(b).map(|(a, b)| a + b))
}

<span class="comment">// Futures also allow chaining computations together, starting another after
// the previous finishes. Here we wait for the first computation to finish,
// and then decide what to do depending on the result.
</span><span class="kw">fn </span>download_timeout(url: <span class="kw-2">&amp;</span>str,
                    timeout_dur: Duration)
                    -&gt; Box&lt;Future&lt;Item=Vec&lt;u8&gt;, Error=io::Error&gt;&gt; {
    <span class="kw">use </span>std::io;
    <span class="kw">use </span>std::net::{SocketAddr, TcpStream};

    <span class="kw">type </span>IoFuture&lt;T&gt; = Box&lt;Future&lt;Item=T, Error=io::Error&gt;&gt;;

    <span class="comment">// First thing to do is we need to resolve our URL to an address. This
    // will likely perform a DNS lookup which may take some time.
    </span><span class="kw">let </span>addr = resolve(url);

    <span class="comment">// After we acquire the address, we next want to open up a TCP
    // connection.
    </span><span class="kw">let </span>tcp = addr.and_then(|addr| connect(<span class="kw-2">&amp;</span>addr));

    <span class="comment">// After the TCP connection is established and ready to go, we&#39;re off to
    // the races!
    </span><span class="kw">let </span>data = tcp.and_then(|conn| download(conn));

    <span class="comment">// That all might take awhile, though, so let&#39;s not wait too long for it
    // to all come back. The `select` combinator here returns a future which
    // resolves to the first value that&#39;s ready plus the next future.
    //
    // Note we can also use the `then` combinator which is similar to
    // `and_then` above except that it receives the result of the
    // computation, not just the successful value.
    //
    // Again note that all the above calls to `and_then` and the below calls
    // to `map` and such require no allocations. We only ever allocate once
    // we hit the `Box::new()` call at the end here, which means we&#39;ve built
    // up a relatively involved computation with only one box, and even that
    // was optional!

    </span><span class="kw">let </span>data = data.map(<span class="prelude-val">Ok</span>);
    <span class="kw">let </span>timeout = timeout(timeout_dur).map(<span class="prelude-val">Err</span>);

    <span class="kw">let </span>ret = data.select(timeout).then(|result| {
        <span class="kw">match </span>result {
            <span class="comment">// One future succeeded, and it was the one which was
            // downloading data from the connection.
            </span><span class="prelude-val">Ok</span>((<span class="prelude-val">Ok</span>(data), _other_future)) =&gt; <span class="prelude-val">Ok</span>(data),

            <span class="comment">// The timeout fired, and otherwise no error was found, so
            // we translate this to an error.
            </span><span class="prelude-val">Ok</span>((<span class="prelude-val">Err</span>(_timeout), _other_future)) =&gt; {
                <span class="prelude-val">Err</span>(io::Error::new(io::ErrorKind::Other, <span class="string">&quot;timeout&quot;</span>))
            }

            <span class="comment">// A normal I/O error happened, so we pass that on through.
            </span><span class="prelude-val">Err</span>((e, _other_future)) =&gt; <span class="prelude-val">Err</span>(e),
        }
    });
    <span class="kw">return </span>Box::new(ret);

    <span class="kw">fn </span>resolve(url: <span class="kw-2">&amp;</span>str) -&gt; IoFuture&lt;SocketAddr&gt; {
        <span class="comment">// ...
    </span>}

    <span class="kw">fn </span>connect(hostname: <span class="kw-2">&amp;</span>SocketAddr) -&gt; IoFuture&lt;TcpStream&gt; {
        <span class="comment">// ...
    </span>}

    <span class="kw">fn </span>download(stream: TcpStream) -&gt; IoFuture&lt;Vec&lt;u8&gt;&gt; {
        <span class="comment">// ...
    </span>}

    <span class="kw">fn </span>timeout(stream: Duration) -&gt; IoFuture&lt;()&gt; {
        <span class="comment">// ...
    </span>}
}</code></pre></div>
<p>Some more information can also be found in the <a href="https://github.com/rust-lang-nursery/futures-rs#futures-rs">README</a> for now, but
otherwise feel free to jump in to the docs below!</p>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.Future"><code>pub use future::<a class="trait" href="future/trait.Future.html" title="trait futures::future::Future">Future</a>;</code></div></li><li><div class="item-name" id="reexport.IntoFuture"><code>pub use future::<a class="trait" href="future/trait.IntoFuture.html" title="trait futures::future::IntoFuture">IntoFuture</a>;</code></div></li><li><div class="item-name" id="reexport.Stream"><code>pub use stream::<a class="trait" href="stream/trait.Stream.html" title="trait futures::stream::Stream">Stream</a>;</code></div></li><li><div class="item-name" id="reexport.Sink"><code>pub use sink::<a class="trait" href="sink/trait.Sink.html" title="trait futures::sink::Sink">Sink</a>;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="executor/index.html" title="mod futures::executor">executor</a></div><div class="desc docblock-short">Executors</div></li><li><div class="item-name"><a class="mod" href="future/index.html" title="mod futures::future">future</a></div><div class="desc docblock-short">Futures</div></li><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod futures::prelude">prelude</a></div><div class="desc docblock-short">A “prelude” for crates using the <code>futures</code> crate.</div></li><li><div class="item-name"><a class="mod" href="sink/index.html" title="mod futures::sink">sink</a></div><div class="desc docblock-short">Asynchronous sinks</div></li><li><div class="item-name"><a class="mod" href="stream/index.html" title="mod futures::stream">stream</a></div><div class="desc docblock-short">Asynchronous streams</div></li><li><div class="item-name"><a class="mod" href="sync/index.html" title="mod futures::sync">sync</a></div><div class="desc docblock-short">Future-aware synchronization</div></li><li><div class="item-name"><a class="mod" href="task/index.html" title="mod futures::task">task</a></div><div class="desc docblock-short">Tasks used to drive a future computation</div></li><li><div class="item-name"><a class="mod" href="unsync/index.html" title="mod futures::unsync">unsync</a></div><div class="desc docblock-short">Future-aware single-threaded synchronization</div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.task_local.html" title="macro futures::task_local">task_local</a></div><div class="desc docblock-short">A macro to create a <code>static</code> of type <code>LocalKey</code></div></li><li><div class="item-name"><a class="macro" href="macro.try_ready.html" title="macro futures::try_ready">try_ready</a></div><div class="desc docblock-short">A macro for extracting the successful type of a <code>Poll&lt;T, E&gt;</code>.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Async.html" title="enum futures::Async">Async</a></div><div class="desc docblock-short">Return type of future, indicating whether a value is ready or not.</div></li><li><div class="item-name"><a class="enum" href="enum.AsyncSink.html" title="enum futures::AsyncSink">AsyncSink</a></div><div class="desc docblock-short">The result of an asynchronous attempt to send a value to a sink.</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Poll.html" title="type futures::Poll">Poll</a></div><div class="desc docblock-short">Return type of the <code>Future::poll</code> method, indicates whether a future’s value
is ready or not.</div></li><li><div class="item-name"><a class="type" href="type.StartSend.html" title="type futures::StartSend">StartSend</a></div><div class="desc docblock-short">Return type of the <code>Sink::start_send</code> method, indicating the outcome of a
send attempt. See <code>AsyncSink</code> for more details.</div></li></ul></section></div></main></body></html>